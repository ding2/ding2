<?php
/**
 * @file
 * Handles display and creation/deletion of reservations for users.
 */

/**
 * Implements hook_ctools_plugin_directory().
 *
 * It simply tells panels where to find the .inc files that define various
 * args, contexts, content_types. In this case the subdirectories of
 * ctools_plugin_example/panels are used.
 */
function ding_reservation_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && !empty($plugin)) {
    return "plugins/$plugin";
  }
}

/**
 * Implements hook_menu().
 */
function ding_reservation_menu() {
  $items = array();

  // @todo ding_reservation really doesn't know that this path is correct. How
  // to handle it?
  $items['user/%user/status/reservations/update/%'] = array(
    'title' => 'Update reservations',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ding_reservation_update_reservations_form', 1, 5),
    'access callback' => 'ding_reservation_access',
    'access arguments' => array(1),
  );

  $items['user/%user/status/reservations/delete/%'] = array(
    'title' => 'Delete reservations',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ding_reservation_delete_reservations_form', 1, 5),
    'access callback' => 'ding_reservation_access',
    'access arguments' => array(1),
  );

  return $items;
}

/**
 * Access callback. Ensure that current user is the same.
 */
function ding_reservation_access($account) {
  global $user;
  return $user->uid == $account->uid;
}

/**
 * Implements hook_ding_entity_menu().
 */
function ding_reservation_ding_entity_menu(&$items, $type, $path, $index) {
  if ($type == 'ding_entity') {
    $items[$path . '/reserve'] = array(
      'title' => 'Reserve',
      'page callback' => 'ding_provider_get_form',
      'page arguments' => array('ding_reservation_reserve_form', $index),
      'access callback' => TRUE,
    );
  }
}

/**
 * Implements hook_ding_entity_buttons().
 */
function ding_reservation_ding_entity_buttons($type, $entity) {
  if ($type == 'ding_entity' && $entity->is('reservable')) {
    return array(ding_provider_get_form('ding_reservation_reserve_form', new DingReservationReservableEntity($entity), TRUE));
  }
}

/**
 * Implements hook_ding_provider_user().
 */
function ding_reservation_ding_provider_user() {
  return array(
    'reservation' => array(
      'required' => TRUE,
      'install time setup' => TRUE,
    ),
  );
}

/**
 * Implements hook_forms().
 *
 * If the forms listing ready and not ready for pickup reservations is listed
 * on the same page, they need to have different form ids in order for Drupal
 * to be able to tell which was submitted. As we're using one builder
 * function, use this to let have their own form id.
 */
function ding_reservation_forms($form_id, $args) {
  return array(
    'ding_reservation_reservations_ready_form' => array(
      'callback' => 'ding_reservation_reservations_form',
    ),
    'ding_reservation_reservations_notready_form' => array(
      'callback' => 'ding_reservation_reservations_form',
    ),
    'ding_reservation_reservations_ill' => array(
      'callback' => 'ding_reservation_reservations_form',
    ),
  );
}

/**
 * Reserve form callback.
 *
 * Note that this form relies on form caching, which is triggered by
 * ajaxifying the submit button.
 */
function ding_reservation_reserve_form($form, &$form_state, $reservable, $hide_options = FALSE) {
  global $user;
  if (!($reservable instanceof DingReservationReservable)) {
    // Assume that we were given a reservable entity.
    $reservable = new DingReservationReservableEntity($reservable);
  }
  $entity = $reservable->getEntity();
  $uri = ding_entity_uri('ding_entity', $entity);

  // We post to our own path as we might want to rebuild the form.
  // @todo move *_get_destination to ding_base?
  if ($_GET['q'] != $uri['path'] . '/reserve') {
    $form['#action'] = url($uri['path'] . '/reserve', array('query' => ding_provider_get_destination()));
  }

  $form['reservable'] = array(
    '#type' => 'value',
    '#value' => $reservable,
  );

  $form['provider_options'] = array(
    '#type' => 'value',
    '#value' => array(),
  );

  $hide_options = !isset($form_state['options_hidden']) ? $hide_options : FALSE;
  $form_state['options_hidden'] = $hide_options;

  if (!$hide_options) {
    if (ding_provider_implements('reservation', 'options') && $provider_form = ding_provider_invoke('reservation', 'options', 'create', $user, $reservable)) {
      $form['provider_options'] = $provider_form + array(
        '#tree' => TRUE,
      );
    }
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Reserve'),
    '#attributes' => array(
      'class' => array(
        'action-button',
        'reserve-button'
      ),
    ),
    '#ajax' => array(
      'callback' => 'ding_reservation_reserve_form_callback',
      'wrapper' => 'ding-reservation-reserve-form',
    ),
  );

  return $form;
}

/**
 * Form validation.
 */
function ding_reservation_reserve_form_validate($form, &$form_state) {
  global $user;
  if (user_is_logged_in() && ding_user_is_provider_user($user)) {
    if (ding_provider_implements('reservation', 'options_validate')) {
      $res = ding_provider_invoke('reservation', 'options_validate', 'create', $user, $form_state['values']['reservable'], $form_state['values']['provider_options']);
      // No valudation options returned by provider.
      if (is_null($res)) {
        return;
      }

      /**
      * We cannot set the value of the individual provider form elements, as
      * they might not have been show, and thus not exist. However, setting the
      * value of the parent element to an associative array gives the same end
      * result.
      */
      $provider_options = array();
      $provider = ding_provider_get_provider_module_name('reservation');
      $removal = array();
      foreach ($res as $key => $value) {
        if (is_array($value) && !empty($value['#error'])) {
          if (!$form_state['options_hidden']) {
            // Only show an error if the user had a choice.
            form_error($form['provider_options'], $res['#error']);
          }
          else {
            // Else simply rebuild the form.
            if ($key == $provider . '_preferred_branch') {
              $removal[] = 'interest_period';
            }
            elseif ($key == 'interest_period') {
              $removal[] = $provider . '_preferred_branch';
            }

            // In case both fields are not set, remove nothing.
            if (count($removal) == 2) {
              $removal = array();
            }

            $form_state['removable'] = $removal;
            $form_state['rebuild'] = TRUE;
          }
        }
        else {
          $provider_options[$key] = $value;
        }
      }
      if (!empty($provider_options)) {
        form_set_value($form['provider_options'], $provider_options, $form_state);
      }
    }
  }
  else {
    throw new DingProviderAuthException();
  }
}

/**
 * Form submission handler.
 */
function ding_reservation_reserve_form_submit($form, &$form_state) {
  global $user;
  if (ding_provider_implements('reservation', 'options_submit')) {
    ding_provider_invoke('reservation', 'options_submit', 'create', $user, $form_state['values']['reservable'], $form_state['values']['provider_options']);
  }
  if ($form_state['values']['reservable']) {
    $reservable = $form_state['values']['reservable'];
    try {
      $reservation_result = ding_provider_invoke('reservation', 'create', $user, $reservable->getProviderId(), $form_state['values']['provider_options']);
      $form_state['reserved'] = TRUE;
      // @todo use profile
      if (!empty($reservation_result['branch']) && ding_provider_implements('reservation', 'branch_name')) {
        $branch_name = ding_provider_invoke('reservation', 'branch_name', $reservation_result['branch']);
        drupal_set_message(t('"@title" reserved and will be available for pickup at @branch.', array('@title' => $reservable->getTitle(), '@branch' => $branch_name)));
      }
      else {
        drupal_set_message(t('"@title" reserved.', array('@title' => $reservable->getTitle())));
      }

      if (is_array($reservation_result) and !empty($reservation_result['queue_number'])) {
        drupal_set_message(t('You are number @number in queue.', array('@number' => $reservation_result['queue_number'])));
      }
    }
    catch (DingProviderUserException $e) {
      drupal_set_message($e->getMessageT(array('@title' => $reservable->getTitle())), 'error');
    }
    catch (DingProviderAuthException $e) {
      // Just rethrow.
      throw $e;
    }
    catch (Exception $e) {
      drupal_set_message(t('An error occurred while reserving item. Please try again later.'), 'error');
      watchdog('ding_reservation', 'Error while reserving, message: @message', array('@message', $e->getMessage()), WATCHDOG_ERROR);
    }
  }
}

/**
 * Ajax callback.
 */
function ding_reservation_reserve_form_callback($form, &$form_state) {
  $response = array(
    '#type' => 'ajax',
    '#commands' => array(),
  );

  $html = theme('status_messages');
  if ($form_state['rebuild'] || form_get_errors()) {
    // Get the default interest period for the current user.
    $default_interest_period = ding_provider_invoke('reservation', 'default_interest_period');

    // Use #value instead of #default_value when rendering forms
    // using drupal_render().
    $form['provider_options']['interest_period']['#value'] = $default_interest_period;

    // Hide certain fields, if any.
    if (is_array($form_state['removable'])) {
      $removal = $form_state['removable'];
      foreach ($removal as $v) {
        unset($form['provider_options'][$v]);
        unset($form['provider_options'][$v . 'description']);
      }

    }
    // Redisplay form.
    $html .= drupal_render($form);
  }

  $response['#commands'][] = ajax_command_ding_popup('ding_reservation', t('Reserve'), $html);

  return $response;
}

/**
 * Show a reservation list form.
 */
function ding_reservation_reservations_form($form, &$form_state, $items = array(), $type = 'not_ready_for_pickup') {
  $options = array();
  $destination = drupal_get_destination();
  $empty_message = '';

  // Check if reservations should be able to be deleted by the user.
  $able_to_delete = FALSE;
  if (ding_provider_implements('reservation', 'reservation_deletion_enabled')) {
    $able_to_delete = ding_provider_invoke('reservation', 'reservation_deletion_enabled');
  }

  switch ($type) {
    case 'ready_for_pickup':
      $header = array(
        'title' => t('Title'),
        'pickup_id' => t('Pickup id'),
        'created' => t('Created date'),
        'pickup_date' => t('Pickup date'),
        'pickup_branch' => t('Pickup branch'),
        'operations' => '',
      );
      uasort($items, 'ding_reservation_sort_queue_by_pickup_date');
      break;

    case 'not_ready_for_pickup':
      $header = array(
        'title' => t('Title'),
        'order_nr' => t('Order nr.'),
        'created' => t('Created date'),
        'expiry' => t('Expiry date'),
        'pickup_branch' => t('Pickup branch'),
        'queue_number' => t('Queue number'),
        'operations' => '',
      );
      uasort($items, 'ding_reservation_sort_queue_by_queue_number');
      break;

    case 'interlibrary_loans':
      $header = array(
        'title' => t('Title'),
        'created' => t('Created date'),
        'expiry' => t('Expiry date'),
        'library' => t('Library'),
        'ill_status' => t('Status'),
      );
      break;
  }

  foreach ($items as $id => $item) {
    $entity = $item->entity;
    if (!is_object($entity)) {
      $entity = ding_provider_get_pseudo_entity($item->ding_entity_id);
    }

    $pickup_branch = ding_provider_invoke('reservation', 'branch_name', $item->pickup_branch_id);
    switch ($type) {
    case 'ready_for_pickup':
      $delete_button = array(
        '#prefix' => '<div class="delete-reservation">',
        '#suffix' => '</div>',
        '#type' => 'submit',
        '#submit' => array('ding_reservation_reservations_delete_submit'),
        '#reservation_id' => $item->id,
        '#name' => 'delete-' . preg_replace('/\W/', '-', $item->id), // Need this for formAPI can tell buttons apart
        '#value' => t('Delete'),
        '#options' => array('query' => $destination),
      );

      $options[$item->id] = array(
        'title' => array(
          'data' => array($entity ? ting_object_view($entity, 'user_list') : array('#markup' => $item->display_name)),
          'class' => 'title',
        ),
        'pickup_id' => array(
          'data' => ding_reservation_get_pickup_id($item),
          'class' => 'pickup-id',
        ),
        'created' => array(
          'data' => $item->created ? format_date(strtotime(check_plain($item->created)), 'date_only') : '',
          'class' => 'created-date',
        ),
        'pickup_date' => array(
          'data' => $item->pickup_date ? format_date(strtotime(check_plain($item->pickup_date)), 'date_only' ) : '',
          'class' => 'pickup-date',
        ),
        'pickup_branch' => array(
          'data' => $pickup_branch ? check_plain($pickup_branch) : '',
          'class' => 'pickup-branch',
        ),
      );

      // Check if able to delete reservation should be added.
      if ($able_to_delete) {
        $options[$item->id]['operations'] = array(
          'data' => $delete_button,
          'class' => 'operations',
        );
      }

      if (!empty($item->notes)) {
        $options[$item->id]['title']['data'][] = array(
          '#type' => 'markup',
          '#prefix' => '<p class="periodical-number">',
          '#markup' => t('(Periodical no. @periodical)', array('@periodical' => check_plain($item->notes))),
          '#suffix' => '</p>',
        );
      }

      $form['reservations'] = array(
        '#type' => 'tableselect_form',
        '#header' => $header,
        '#options' => $options,
        '#empty' => t('No reservations ready for pickup'),
      );
      break;

    case 'not_ready_for_pickup':
      $options[$item->id] = array(
        'title' => array(
          'data' => array($entity ? ting_object_view($entity, 'user_list') : array('#markup' => $item->display_name)),
          'class' => 'title',
        ),
        'order_nr' => array(
          'data' => ding_reservation_get_order_nr($item),
          'class' => 'pickup-id',
        ),

        'created' => array(
          'data' => $item->created ? format_date(strtotime(check_plain($item->created)), 'date_only') : '',
          'class' => 'created-date',
        ),
        'expiry' => array(
          'data' => $item->created ? format_date(strtotime(check_plain($item->expiry)), 'date_only') : '',
          'class' => 'expire-date',
        ),
        'pickup_branch' => array(
          'data' => $pickup_branch ? check_plain($pickup_branch) : '',
          'class' => 'pickup-branch',
        ),
        'queue_number' => array(
          'data' => $item->queue_number ? check_plain($item->queue_number) : '',
          'class' => 'queue-number',
        ),
        'operations' => array(
          'data' => array(
            '#prefix' => '<div class="delete-reservation">',
            '#suffix' => '</div>',
            '#type' => 'submit',
            '#submit' => array('ding_reservation_reservations_delete_submit'),
            '#reservation_id' => $item->id,
            '#name' => 'delete-' . preg_replace('/\W/', '-', $item->id), // Need this for formAPI can tell buttons apart
            '#value' => t('Delete'),
            '#options' => array('query' => $destination),
          ),
          'class' => 'operations',
        ),
      );

      if (!empty($item->notes)) {
        $options[$item->id]['title']['data'][] = array(
          '#type' => 'markup',
          '#prefix' => '<p class="periodical-number">',
          '#markup' => t('(Periodical no. @periodical)', array('@periodical' => check_plain($item->notes))),
          '#suffix' => '</p>',
        );
      }

      $form['reservations'] = array(
        '#type' => 'tableselect_form',
        '#header' => $header,
        '#options' => $options,
        '#empty' => t('No Reservations'),
      );
      break;

    case 'interlibrary_loans':
      $options[$item->id] = array(
        'title' => array(
          'data' => array($entity ? ting_object_view($entity, 'user_list') : array('#markup' => $item->display_name)),
          'class' => 'title',
        ),
        'created' => array(
          'data' => $item->created ? format_date(strtotime(check_plain($item->created)), 'date_only') : '',
          'class' => 'created-date',
        ),
        'expiry' => array(
          'data' => $item->created ? format_date(strtotime(check_plain($item->expiry)), 'date_only') : '',
          'class' => 'expire-date',
        ),
        'library' => array(
          'data' => $pickup_branch ? check_plain($pickup_branch) : '',
          'class' => 'pickup-branch',
        ),
        'ill_status' => array(
          'data' => $item->ill_status ? t(check_plain($item->ill_status)) : '',
          'class' => 'ill-status',
        ),
      );

      if (!empty($item->notes)) {
        $options[$item->id]['title']['data'][] = array(
          '#type' => 'markup',
          '#prefix' => '<p class="periodical-number">',
          '#markup' => t('(Periodical no. @periodical)', array('@periodical' => check_plain($item->notes))),
          '#suffix' => '</p>',
        );
      }

      $form['reservations'] = array(
        '#type' => 'tableselect_form',
        '#header' => $header,
        '#options' => $options,
        '#empty' => t('No inter-library loans'),
      );
      break;
    }
  }

  if ($able_to_delete) {
    $form['reservations'] = array(
      '#type' => 'tableselect_form',
      '#header' => $header,
      '#options' => $options,
      '#empty' => $empty_message,
    );
  }
  else {
    $form['reservations'] = array(
      '#type' => 'item',
      '#markup' => theme('table', array('header' => $header, 'rows' => $options, 'empty' => $empty_message)),
    );
  }

  $form['actions_top'] = array(
    '#weight' => -10,

  );

  if ($able_to_delete) {
    $form['actions_top']['delete'] = array(
      '#prefix' => '<div class="delete-reservations">',
      '#suffix' => '</div>',
      '#submit' => array('ding_reservation_deletes_form_submit'),
      '#type' => 'submit',
      '#value' => t('Delete reservations'),
      '#ajax' => array(
        'callback' => 'ding_reservation_deletes_form_callback',
        'wrapper' => 'ding-reservation-reservations-form',
      ),
    );
  }

  if ($type == 'not_ready_for_pickup') {
    $form['actions_top']['update'] = array(
      '#prefix' => '<div class="update-reservations">',
      '#suffix' => '</div>',
      '#type' => 'submit',
      '#submit' => array('ding_reservation_updates_form_submit'),
      '#value' => t('Update reservations'),
      '#ajax' => array(
        'callback' => 'ding_reservation_updates_form_callback',
        'wrapper' => 'ding-reservation-updates-form',
      ),
    );
  }

  $form['actions_bottom'] = array(
    '#weight' => 10,
  );

  if ($able_to_delete) {
    $form['actions_bottom']['delete'] = array(
      '#prefix' => '<div class="delete-reservations">',
      '#suffix' => '</div>',
      '#submit' => array('ding_reservation_deletes_form_submit'),
      '#type' => 'submit',
      '#value' => t('Delete reservations'),
      '#ajax' => array(
        'callback' => 'ding_reservation_deletes_form_callback',
        'wrapper' => 'ding-reservation-reservations-form',
      ),
    );
  }

  if ($type == 'not_ready_for_pickup') {
    $form['actions_bottom']['update'] = array(
      '#prefix' => '<div class="update-reservations">',
      '#suffix' => '</div>',
      '#type' => 'submit',
      '#submit' => array('ding_reservation_updates_form_submit'),
      '#value' => t('Update reservations'),
      '#ajax' => array(
        'callback' => 'ding_reservation_updates_form_callback',
        'wrapper' => 'ding-reservation-updates-form',
      ),
    );
  }

  return $form;
}

/**
 * Get pickup id number.
 *
 * @param object $item
 *  Reserved item object.
 * @return int
 *  Pickup id, if any.
 */
function ding_reservation_get_pickup_id($item) {
  if (isset($item->order_arrived) && !$item->order_arrived) {
    return t('The material is in transit and is still not available for loan on the library');
  }
  elseif (isset($item->pickup_order_id)) {
    return $item->pickup_order_id;
  }

  return '';
}

/**
 * Get order id number.
 *
 * @param object $item
 *  Reserved item object.
 * @return int
 *  Order number, if any.
 */
function ding_reservation_get_order_nr($item) {
  if (!isset($item->pickup_order_id) && isset($item->order_id)) {
    return $item->order_id;
  }
  else {
    return t('On route') . ' ' . l('(?)', current_path(), array('attributes' => array('title' => t('The material is on route to the library. You will be notified when it is ready for pickup.'))));
  }
}

/**
 * Submit handler for the reservations form.
 */
function ding_reservation_reservations_delete_submit($form, &$form_state) {
  global $user;
  if (!empty($form_state['triggering_element']['#reservation_id'])) {
    $reservations = array($form_state['triggering_element']['#reservation_id']);
  }
  else {
    $reservations = array_filter($form_state['values']['reservations']);
  }
  foreach ($reservations as $entity_id) {
    ding_provider_invoke('reservation', 'delete', $user, $entity_id);
  }
}

/**
 * Submit handler for the delete form.
 */
function ding_reservation_deletes_form_submit($form, &$form_state) {
  global $user;
  $ids = join(',', array_map('rawurlencode', array_filter($form_state['values']['reservations'], 'is_string')));
  $form_state['encoded_reservations'] = $ids;
  $form_state['redirect'] = array('user/' . $user->uid . '/status/reservations/delete/' . $ids, array('query' => drupal_get_destination()));
}

/**
 * Submit handler for the update form.
 */
function ding_reservation_updates_form_submit($form, &$form_state) {
  global $user;
  $ids = join(',', array_map('rawurlencode', array_filter($form_state['values']['reservations'], 'is_string')));
  $form_state['encoded_reservations'] = $ids;
  $form_state['redirect'] = array('user/' . $user->uid . '/status/reservations/update/' . $ids, array('query' => drupal_get_destination()));
}

/**
 * Ajax callback for the delete form.
 */
function ding_reservation_deletes_form_callback($form, &$form_state) {
  global $user;
  $response = array(
    '#type' => 'ajax',
    '#commands' => array(),
  );

  $html = theme('status_messages');
  $html .= drupal_render(drupal_get_form('ding_reservation_delete_reservations_form', $user, $form_state['encoded_reservations']));

  if ($html) {
    $response['#commands'][] = ajax_command_ding_popup('ding_reservation', t('Delete reservations'), $html, array('refresh' => TRUE));
  }
  return $response;
}

/**
 * Ajax callback for the update form.
 */
function ding_reservation_updates_form_callback($form, &$form_state) {
  global $user;
  $response = array(
    '#type' => 'ajax',
    '#commands' => array(),
  );

  $html = theme('status_messages');
  $html .= drupal_render(drupal_get_form('ding_reservation_update_reservations_form', $user, $form_state['encoded_reservations']));

  if ($html) {
    $response['#commands'][] = ajax_command_ding_popup('ding_reservation', t('Update reservations'), $html, array('refresh' => TRUE));
  }
  return $response;
}

/**
 * Delete reservations form.
 */
function ding_reservation_delete_reservations_form($form, $form_state, $account, $reservation_ids) {
  global $user;
  $ids = array_map('rawurldecode', explode(',', $reservation_ids));

  $form_state['cache'] = TRUE;

  $form['reservations'] = array(
    '#type' => 'value',
    '#value' => $ids,
  );

  $form['confirm_text'] = array(
    '#markup' => '<div>' . t('Are you sure you want to delete these reservations?') . '</div>',
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#submit' => array('ding_reservation_delete_reservations_form_submit'),
    '#ajax' => array(
      'callback' => 'ding_reservation_delete_reservations_form_callback',
      'wrapper' => 'ding-reservation-delete-reservation-form',
    ),
    '#value' => t('Yes'),
    '#name' => 'delete_reservations',
  );

  $form['cancel'] = array(
    '#type' => 'link',
    '#title' => t('Cancel'),
    '#href' => 'user/' . $user->uid . '/status/reservations',
    '#value' => t('Cancel'),
  );

  return $form;
}

/**
 * Update reservations form.
 */
function ding_reservation_update_reservations_form($form, $form_state, $account, $reservation_ids) {
  global $user;
  $ids = array_map('rawurldecode', explode(',', $reservation_ids));

  $form_state['cache'] = TRUE;

  $form['reservations'] = array(
    '#type' => 'value',
    '#value' => $ids,
  );

  if (ding_provider_implements('reservation', 'options') && $provider_form = ding_provider_invoke('reservation', 'options', 'update', $user, NULL)) {
    $form['provider_options'] = $provider_form + array(
      '#tree' => TRUE,
    );
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#submit' => array('ding_reservation_update_reservations_form_submit'),
    '#ajax' => array(
      'callback' => 'ding_reservation_update_reservations_form_callback',
      'wrapper' => 'ding-reservation-update-reservation-form',
    ),
    '#value' => t('Update reservations'),
  );
  return $form;
}

/**
 * Validation handler.
 */
function ding_reservation_update_reservations_form_validate($form, &$form_state) {
  global $user;
  if (ding_provider_implements('reservation', 'options_validate')) {
    $res = ding_provider_invoke('reservation', 'options_validate', 'update', $user, $form_state['values']['reservations'], $form_state['values']['provider_options']);
    /**
     * We cannot set the value of the individual provider form elements, as
     * they might not have been show, and thus not exist. However, setting the
     * value of the parent element to an associative array gives the same end
     * result.
     */
    $provider_options = array();
    foreach ($res as $key => $value) {
      if (is_array($value) && !empty($value['#error'])) {
        if (!$form_state['options_hidden']) {
          // Only show an error if the user had a choice.
          form_error($form['provider_options'], $res['#error']);
        }
        else {
          // Else simply rebuild the form.
          $form_state['rebuild'] = TRUE;
        }
      }
      else {
        $provider_options[$key] = $value;
      }
    }
    if (!empty($provider_options)) {
      form_set_value($form['provider_options'], $provider_options, $form_state);
    }
  }
}

/**
 * Submit handlers.
 *
 */
function ding_reservation_delete_reservations_form_submit($form, &$form_state) {
  global $user;
  if (!empty($form_state['triggering_element']['#reservation_id'])) {
    $reservations = array($form_state['triggering_element']['#reservation_id']);
  }
  else {
    $reservations = array_filter($form_state['values']['reservations']);
  }
  foreach ($reservations as $entity_id) {
    ding_provider_invoke('reservation', 'delete', $user, $entity_id);
  }
}

function ding_reservation_update_reservations_form_submit($form, &$form_state) {
  global $user;
  ding_provider_invoke('reservation', 'update', $user, $form_state['values']['reservations'], $form_state['values']['provider_options']);
}

/**
 * Ajax callback functions.
 */
function ding_reservation_delete_reservations_form_callback($form, &$form_state) {
  $response = array(
    '#type' => 'ajax',
    '#commands' => array(),
  );

  $html = theme('status_messages') . t('Your reservations have been deleted.');
  $response['#commands'][] = ajax_command_ding_popup('ding_reservation', t('Delete reservations'), $html, array('refresh' => TRUE));

  return $response;
}

function ding_reservation_update_reservations_form_callback($form, &$form_state) {
  $response = array(
    '#type' => 'ajax',
    '#commands' => array(),
  );

  $html = theme('status_messages') . t('Your reservations has been updated.');
  $response['#commands'][] = ajax_command_ding_popup('ding_reservation', t('Update reservations'), $html, array('refresh' => TRUE));

  return $response;
}

/**
 * Default options handling.
 *
 * Reservation providers may use these to use standard implementations of
 * widgets like pickup branch and get much logic for free.
 */

/**
 * Create a pickup branch selector.
 *
 * Returns form element(s) for selecting a pickup branch.
 */
function ding_reservation_default_options_branch($type, $name, $default, $options) {
  $create = ($type == 'create');
  $allowed_branches = ($create ? array('' => 'Select') : array($default => t('No change'))) + (array)$options;
  $default_value = $default;
  $form[$name] = array(
    '#type' => 'select',
    '#title' => t('Select branch'),
    '#options' => $allowed_branches,
    '#default_value' => $default_value,
  );
  if ($create) {
    $form[$name . 'description'] = array(
      '#markup' => '<p>' . t('In order to make quick reservations, you must select a default pickup branch.') . '</p>',
    );
  }
  return $form;
}


/**
 * Create an interest period form select element.
 *
 * @TODO: Find a better solution on this type variable.
 *
 * @param string $type
 *  The type of form element to create.
 * @param string $name
 *  Form element name
 * @param int $default
 *  The pre-selected value.
 * @param array $options
 *  The options that should be available in the dropdown.
 * @return array $form
 *  Form select element.
 */
function ding_reservation_interest_period_selector($type, $name, $default, $options) {
  $form = array();

  // Used to enable translation of options.
  if (is_array($options)) {
    foreach ($options as $k => $v) {
      $options[$k] = t(check_plain($v));
    }
  }

  $allowed_periods = ($type == 'create' ? array() : array('' => t('No change'))) + (array)$options;
  $form[$name] = array(
    '#type' => 'select',
    '#title' => t('Select interest period'),
    '#options' => $allowed_periods,
    '#default_value' => $default,
  );

  if ($type == 'create') {
    $form[$name . 'description'] = array(
      '#markup' => '<p>' . t('Select an interest period.') . '</p>',
    );
  }

  return $form;
}


/**
 * Validate pickup branch selector.
 *
 * Returns what ding_reservation expects.
 */
function ding_reservation_default_options_branch_validate($type, $name, $default, $values) {
  if (empty($values[$name])) {
    $provider = ding_provider_get_provider_module_name('reservation');
    if ($type == 'create' && empty($default)) {
      $result[$provider . '_preferred_branch'] = array(
        '#error' => t('You must select a branch'),
      );
    }
    else {
      $result[$name] = $default;
    }
    return $result;
  }
  else {
    return $values;
  }
}

/**
 * Validate interest period selector.
 *
 * Returns what ding_reservation expects.
 */
function ding_reservation_default_options_interest_period_validate($type, $name, $default, $values) {
  if (empty($values[$name])) {
    $result = array();
    if ($type == 'create' && empty($default)) {
      $result['interest_period'] = array(
        '#error' => t('You must select an interest period'),
      );
    }
    else {
      $result[$name] = $default;
    }
    return $result;
  }
  else {
    return $values;
  }
}

/**
 * Submit pickup branch selector.
 *
 * Returns new properties to save, if any.
 */
function ding_reservation_default_options_branch_submit($type, $name, $default, $values) {
  $result = array();
  if ($type == 'create' && !empty($values[$name]) && $values[$name] != $default) {
    $result[$name] = $values['name'];
  }
  return $result;
}


/**
 * Callback function to sort array by pickup date
 */
function ding_reservation_sort_queue_by_pickup_date($a, $b) {
  if ($a->pickup_date == $b->pickup_date) {
    return 0;
  }
  return ($a->pickup_date < $b->pickup_date) ? -1 : 1;
}

/**
 * Callback function for sorting loans by queue_number
 */
function ding_reservation_sort_queue_by_queue_number($a, $b) {
  if ($a->queue_number == $b->queue_number) {
    return 0;
  }
  return ($a->queue_number < $b->queue_number) ? -1 : 1;
}

/**
 * Interface for reservable items.
 */
interface DingReservationReservable {
  public function getProviderId();
  // @todo, this should be optional.
  public function getEntity();
  public function getTitle();
}

/**
 * A reservable entity.
 */
class DingReservationReservableEntity implements DingReservationReservable {
  public function __construct($entity) {
    $this->entity = $entity;
  }

  public function getProviderId() {
    return isset($this->entity->provider_id) ? $this->entity->provider_id : NULL;
  }

  public function getEntity() {
    return $this->entity;
  }

  public function getTitle() {
    return isset($this->entity->record['dc:title'][''][0]) ? $this->entity->record['dc:title'][''][0] : '';
  }
}

