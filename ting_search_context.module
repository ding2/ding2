<?php

/**
 * @file
 *
 * Module file for the Ting search context module.
 */

// Constants
define('TING_SEARCH_CONTEXT_PATH', drupal_get_path('module', 'ting_search_context'));
define('TING_SEARCH_CONTEXT_MAX_RATING', 10);
define('TING_SEARCH_CONTEXT_NODE_TYPES', serialize(array(
	'ding_library',
	'ding_campaign',
	'ding_page',
	'ding_news',
	'ding_event',
)));

/**
 * Implements hook_menu().
 */
function ting_search_context_menu() {
	$items['admin/content/ting-search-context'] = array(
		'title' => 'Search context',
		'description' => 'Manage the state of the context rating system.',
		'page callback' => 'drupal_get_form',
		'page arguments' => array('ting_search_context_overview_form'),
		'access arguments' => array('administer content'), // Todo: Make own permission?
		'type' => MENU_LOCAL_TASK | MENU_NORMAL_ITEM,
		'file' => 'ting_search_context.admin.inc',
	);
  $items['ting/searchcontext/ajax'] = array(
    'title' => 'Get content related to search context ',
    'page callback' => 'ting_search_context_ajax_get_related_content',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/ting/ting-search-context'] = array(
    'title' => 'Search context',
    'description' => 'Choose location of related content on search page',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ting_search_context_admin_settings_form'),
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'ting_search_context.admin.inc',
  );
  return $items;
}

/**
 * Implements hook_theme().
 */
function ting_search_context_theme($existing, $type, $theme, $path) {
  return array(
    'ting_search_context' => array(
      'variables' => array('columns' => NULL),
      'template'  => 'ting-search-context',
      'path' => $path . '/templates',
    ),
  );
}

/**
 * Implements hook_ctools_plugin_directory().
 *
 * It simply tells panels where to find the .inc files that define various
 * args, contexts, content_types.
 */
function ting_search_context_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && !empty($plugin)) {
    return "plugins/$plugin";
  }
}

function ting_search_context_ajax_get_related_content() {
  $search_context = $_POST['search_context'];
  $nodes = ting_search_context_get_context($search_context);
  $output = '';
  if (!empty($nodes)) {
    $output = ting_search_context_theme_output ($nodes);
  }
  return drupal_json_output($output);
}

function ting_search_context_theme_output($nodes) {
  $columns = array();
  $columns_classes = array(
    ' ting-search-context-blocks--first',
    ' ting-search-context-blocks--second',
    ' ting-search-context-blocks--third',
    ' ting-search-context-blocks--fourth',
  );
  foreach ($columns_classes as $columns_class) {
    if (!empty($nodes)) {
      $node = array_shift($nodes);
      $field_name = ting_search_context_get_image_field_name($node);
      $image = field_view_field('node', $node, $field_name, array(
        'label' => 'hidden',
        'settings' => array(
          'image_style' => 'ting_search_context', // We take care of the linking ourself
        ),
      ));
      $url = url(drupal_get_path_alias('node/' . $node->nid), array('absolute' => TRUE));
      $url .= '?WT.cg_n=searchcontext';
      $columns[$columns_class] = array(
        'title' => $node->title,
        'image' => drupal_render($image),
        'url' => $url,
      );
    }
  }
  return theme('ting_search_context', array('columns' => $columns));
}

function ting_search_context_get_image_field_name($node) {
  $type = $node->type;
  if ($type == 'ding_news') {
    return 'field_ding_news_list_image';
  } else if ($type == 'ding_event') {
    return 'field_ding_event_list_image';
  } else if ($type == 'ding_eresource') {
    return 'field_ding_eresource_list_image';
  } else if ($type == 'genre_page') {
    return 'field_genre_page_list_image';
  } else if ($type == 'ding_page') {
    return 'field_ding_page_list_image';
  }
  return '';
}

/**
 * Get information about the current state of the context rating system.
 *
 * @param $context_names (TODO: Not implemented yet.)
 *   Can either be a string specifying a single context name or an array of
 *   context names. Defaults to all which returns info on all contexts defined
 *   in the system.
 *
 * @return
 *   An array of each context defined in the system keyed context machine name,
 *   with information about label and ratings.
 */
function ting_search_context_get_context_info($context_names = 'all') {
	$return = array();
	// Retrieve the contexts defined in the system.
	$contexts = ting_search_context_get_contexts();
	// Loop through each context and set up the information
	foreach ($contexts as $name => $label) {
		$query_common = db_select('field_data_field_ting_search_context', 'fd')
			->condition('fd.field_ting_search_context_name', $name, '=');
		$return[$name]['label'] = $label;
		$return[$name]['ratings'] = array();
		// The total rating count.
		$total_count = 0;
 		for ($rating = TING_SEARCH_CONTEXT_MAX_RATING; $rating > 0; $rating--) {
			$query = clone $query_common;
			$query->condition('fd.field_ting_search_context_rating', $rating, '=');
			$count = $query->countQuery()->execute()->fetchField();
			$return[$name]['ratings'][$rating] = $count;
			$total_count += $count;
		}
		$return[$name]['total_count'] = $total_count;
	}
	return $return;
}

/**
 * Get random node content in the specified context.
 *
 * @param $name
 *   The machine-name of the context to get content from.
 * @param $count (optional)
 *   The max number of nodes to return. Defaults to 5.
 * @param $node_types (optional)
 *   Can either be a string with a single node type, or an array of node types.
 *   Defaults to 'all' which includes all supported node types.
 *
 * @return
 *   An array of node objects keyd by nid.
 *
 * @see _ting_search_context_get_contexts()
 */
function ting_search_context_get_context($name, $count = 5, $node_types = 'all') {
	// Intialize our return array.
	$return = array();
	// Return empty array if current user doesn't have permission to view
	// published content.
	if (!user_access('access content')) {
		return $return;
	}
	// Get the node types we support.
	$supported_types = unserialize(TING_SEARCH_CONTEXT_NODE_TYPES);
	// Normalize the $node_types parameter.
	if ($node_types === 'all') {
		$node_types = $supported_types;
	}
	else {
		$node_types = (is_array($node_types) ? $node_types : array($node_types));
	}

	// Return an empty array in case of invalid input.
	if (empty($node_types) || $count < 1) {
		return $return;
	}

	// Setup a common query.
	$query = db_select('node', 'n');
	$query->join('field_data_field_ting_search_context', 'fd', 'n.nid = fd.entity_id');
	$query->addField('n', 'nid', 'nid');
	$query->addField('fd', 'field_ting_search_context_rating', 'rating');
	$query->condition('fd.field_ting_search_context_name', $name, '=')
		->condition('n.status', 1, '=')
		// Tell the node system that we are accessing the node table. It will take
		// care of checking if the current user has access to view the nodes.
		->addTag('node_access');
	// The node types should have an 'or' conjuction.
	$node_types_condition = db_or();
	foreach ($node_types as $node_type) {
		$node_types_condition->condition('fd.bundle', $node_type);
	}
	$query->condition($node_types_condition);

	// Fetch nodes with max rating.
	$query_max = clone $query;
	$query_max->condition('fd.field_ting_search_context_rating',
		TING_SEARCH_CONTEXT_MAX_RATING, '=')->range(0, $count);
	$query_max_count = $query_max->countQuery()->execute()->fetchField();
	$query_max_result = $query_max->orderRandom()->execute();
	foreach ($query_max_result as $record) {
		$return[$record->nid] = node_load($record->nid);
	}
	// Update the $count variable so we know how much there's left.
	$count -= $query_max_count;

	// If there's room for more, look for nodes with less than max rating.
	if ($count > 0) {
		$query_less = clone $query;
		$query_less->condition('fd.field_ting_search_context_rating',
			TING_SEARCH_CONTEXT_MAX_RATING, '<');
		$query_less_count = $query_less->countQuery()->execute()->fetchField();
		$query_less_result = $query_less->execute();
		// If there's more nodes rated in the context than we have room for, pick
		// which ones to include randomly so that nodes with higher rating has a
		// higher chance.
		if ($query_less_count > $count) {
			$nodes = array();
			foreach ($query_less_result as $record) {
				$rating = $record->rating;
				for ($i = 0; $i < $rating; $i++) {
					$nodes[] = $record->nid;
				}
			}
			while ($count > 0 && count($nodes) > 0) {
				$random_key = array_rand($nodes);
				$nid = $nodes[$random_key];
				// Remove the node completely from the array.
				$keys = array_keys($nodes, $nid);
				foreach ($keys as $key) {
					unset($nodes[$key]);
				}
				$return[$nid] = node_load($nid);
				$count--;
			}
		}
		// Else, if we have more room than needed, we include all nodes returned
		// from the query.
		else  {
			foreach ($query_less_result as $record) {
				$return[$record->nid] = node_load($record->nid);
			}
		}
	}

	return $return;
}


/**
 * Implements hook_field_info().
 *
 * Here we describe our custom context field, which is used to rate nodes in
 * the different contexts supported by the module.
 */
function ting_search_context_field_info() {
	return array(
		'ting_search_context' => array(
			'label' => t('Search context'),
			'description' => t('Associate ding nodes with different search contexts.'),
			'default_widget' => 'ting_search_context_select',
			'default_formatter' => 'ting_search_context_default',
			// This field is not meant to be controlled through the admin UI, but
			// is instead added programmatically when this module is enabled.
			'no_ui' => TRUE,
		),
	);
}

/**
 * Implements hook_field_is_empty().
 */
function ting_search_context_field_is_empty($item, $field) {
	if ($field['type'] == 'ting_search_context') {
		// If no context was selected our field is empty.
		if (empty($item['name'])) {
			return TRUE;
		}
	}
	return FALSE;
}

/**
 * Implements hook_field_widget_info().
 */
function ting_search_context_field_widget_info() {
	return array(
		'ting_search_context_select' => array(
		  'label' => t('Select boxes'),
		  'description' => t('Rate context on nodes with select boxes.'),
		  'field types' => array('ting_search_context'),
		  'behaviors' => array(
		  	'multiple values' => FIELD_BEHAVIOR_DEFAULT,
		  	'default value' => FIELD_BEHAVIOR_NONE,
		  ),
		),
	);
}

/**
 * Implements hook_field_widget_form().
 */
function ting_search_context_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
	$name = isset($items[$delta]['name']) ? $items[$delta]['name'] : 0;
	$rating = isset($items[$delta]['rating']) ? $items[$delta]['rating'] : 1;
	$base = $element;
	if ($instance['widget']['type'] == 'ting_search_context_select') {
		$options = array();
		$options[0] = '- ' . t('None') . ' -';
		$options += ting_search_context_get_contexts();
		$element['name'] = array(
			'#type' => 'select',
			'#title' => t('Name'),
			'#options' => $options,
			'#default_value' => $name,
			'#weight' => -25,
			'#attributes' => array(
				'class' => array('field_ting_search_context_name'),
			),
		) + $base;
		$options = array();
		for ($i = 1; $i <= TING_SEARCH_CONTEXT_MAX_RATING; $i++) {
			$options[$i] = $i;
		}
		$element['rating'] = array(
			'#type' => 'select',
			'#title' => t('Rating'),
			'#options' => $options,
			'#default_value' => $rating,
			'#weight' => -24,
			'#attributes' => array(
				'class' => array('field_ting_search_context_rating'),
			),
		) + $base;
		$element['remove'] = array(
			'#type' => 'button',
			'#value' => t('Remove'),
			'#weight' => -23,
			'#attributes' => array(
				'class' => array('field_ting_search_context_remove'),
			),
		) + $base;
		$css_path = TING_SEARCH_CONTEXT_PATH . '/css/ting_search_context.form.css';
		$js_path = TING_SEARCH_CONTEXT_PATH . '/js/ting_search_context.form.js';
		// If there are many fields the last JS and CSS will 'win'.
		$element['#attached']['css'][] = $css_path;
		$element['#attached']['js'][] = $js_path;
	}
	return $element;
}

/**
 * Implements hook_field_validate().
 *
 * Make sure that each node only has one weight in each context.
 */
function ting_search_context_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
	if ($field['type'] == 'ting_search_context') {
		$context_names = array();
		foreach ($items as $delta => $item) {
			$context_name = $item['name'];
			// Each context should only be rated once pr node.
			if (in_array($context_name, $context_names)) {
				$errors[$field['field_name']][$langcode][$delta][] = array(
					'error' => 'field_ting_search_context_multiple',
					'message' => t('This node is already rated in that context.'),
				);
			}
			else if ($context_name) {
				$context_names[] = $context_name;
			}
		}
	}
}

/**
 * Implements hook_field_widget_error().
 */
function ting_search_context_field_widget_error($element, $error, $form, &$form_state) {
	switch ($error['error']) {
		case 'field_ting_search_context_multiple':
			form_error($element, $error['message']);
			break;
	}
}

/**
 * Implements hook_field_formatter_info().
 */
function ting_search_context_field_formatter_info() {
	return array(
		'ting_search_context_default' => array(
			'label' => t('Default'),
			'field types' => array('ting_search_context'),
		),
	);
}

/**
 * Implements hook_field_formatter_view().
 */
function ting_search_context_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
	$element = array();
	if ($display['type'] == 'ting_search_context_default') {
		$contexts = _ting_search_context_get_contexts();
		foreach ($items as $delta => $item) {
			$element[$delta] = array(
				'#type' => 'html_tag',
				'#tag' => 'p',
				'#value' => t('Name: @name | Rating: @rating', array(
					'@name' => $contexts[$item['name']],
					'@rating' => $item['rating'],
				)),
			);
		}
	}
	return $element;
}

/**
 * Returns an array with the contexts we support.
 */
function ting_search_context_get_contexts() {
	return array(
		'film' => 'Film',
		'music' => 'Musik',
		'fiction' => 'Skøn',
		'nonfiction' => 'Fag',
		'children' => 'Børn',
    'drenge' => 'Drenge',
    'krimi' => 'Krimi',
    'kærlighed' => 'Kærlighed',
    'fantasy' => 'Fantasy',
    'haver' => 'Havebøger',
    'kogebøger' => 'Kogebøger',
    'piger' => 'Piger',
	);
}

/**
 * Defines the positions for placing the related content on the search page.
 *
 * @return array
 *   Indexed by position name.
 */
function ting_search_context_get_positions() {
  return array(
    'js-below-search-result' => t('Below search result'),
    'js-below-facets' => t('Below facets'),
    'js-above-search-result' => t('Above search result'),
  );
}

/**
 * Implements hook_image_default_styles().
 */
function ting_search_context_image_default_styles() {
  return array(
    'ting_search_context' => array(
      'name' => 'ting_search_context',
      'effects' => array(
        array(
          'label' => 'Scale and crop',
          'effect callback' => 'image_scale_and_crop_effect',
          'dimensions callback' => 'image_resize_dimensions',
          'module' => 'image',
          'name' => 'image_scale_and_crop',
          'data' => array(
            'width' => '540',
            'height' => '370',
          ),
          'weight' => '1',
        ),
      ),
    ),
  );
}
