<?php

/**
 * @file
 * Base setup and functions for Ding!.
 */

include_once 'ding_base.features.inc';

/**
 * Implements hook_menu().
 *
 * Provides the Configuration page block for all Ding modules.
 */
function ding_base_menu() {
  $items = array();

  $items['admin/config/ding'] = array(
    'title' => 'Ding',
    'description' => 'Manage Ding.',
    'position' => 'right',
    'weight' => 20,
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('access administration pages'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  );

  $items['ding_base/taxonomy/autocomplete'] = array(
    'title' => 'Autocomplete taxonomy',
    'page callback' => 'ding_base_taxonomy_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function ding_base_theme() {
  return array(
    // Used on the user library status pages.
    'material_item' => array(
      'render element' => 'element',
      'template' => 'templates/material_item',
    ),
    'tableselect_form' => array(
      'render element' => 'element',
    ),
    'body_snippet' => array(
      'variables' => array('element' => NULL),
    ),
  );
}

/**
 * Implements s a theme function for body_snippet.
 */
function theme_body_snippet($element) {
  $element_string = strip_tags($element['element']['value']);
  $element_string = preg_replace('/\[\[.*\]\]/', '', $element_string);
  $element_string = html_entity_decode($element_string, ENT_NOQUOTES, 'utf-8');
  $element_string = drupal_substr($element_string, 0, $element['display']['settings']['body_snippet_length']);
  return $element_string;
}

/**
 * Implements hook_field_formatter_info().
 */
function ding_base_field_formatter_info() {
  return array(
    'body_snippet' => array(
      'label' => t('Show plaintext part of string'),
      'field types' => array('text', 'text_long'),
      'settings' => array('body_snippet_length' => 100),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function ding_base_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $elements = array();
  foreach ($items as $delta => $item) {
    $elements[$delta] = array(
      '#markup' => theme('body_snippet', array(
        'element' => $item,
        'field' => $instance,
        'display' => $display,
      )),
    );
  }
  return $elements;
}

/**
 * Field formatter settings form.
 */
function ding_base_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $element = array();
  if ($display['type'] == 'body_snippet') {
    $element['body_snippet_length'] = array(
      '#title' => t('Trim length'),
      '#type' => 'textfield',
      '#size' => 10,
      '#default_value' => $settings['body_snippet_length'],
      '#element_validate' => array('_element_validate_integer_positive'),
      '#required' => TRUE,
    );
  }
  return $element;
}

/**
 * Returns summary for field settings.
 */
function ding_base_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $summary = '';

  if ($display['type'] == 'body_snippet') {
    $summary = t('Trim length') . ': ' . $settings['body_snippet_length'];
  }

  return $summary;
}

/**
 * Implements hook_date_formats().
 */
function ding_base_date_formats() {
  return array(
    array(
      'type' => 'ding_date_only',
      'format' => 'l j. F',
      'locales' => array(),
    ),
    array(
      'type' => 'ding_event_lists_date',
      'format' => 'l j. F Y',
      'locales' => array(),
    ),
    array(
      'type' => 'ding_material_lists_date',
      'format' => 'j. F Y',
      'locales' => array(),
    ),
    array(
      'type' => 'ding_long_date_only',
      'format' => 'l j. F Y',
      'locales' => array(),
    ),
    array(
      'type' => 'ding_time_only',
      'format' => 'G:i',
      'locales' => array(),
    ),
    array(
       // New default drupal selectable short format.
      'type' => 'short',
      'format' => 'd-m-Y H:i',
      'locales' => array(),
    ),
    array(
      // New default drupal selectable medium format.
      'type' => 'medium',
      'format' => 'D, d-m-Y H:i',
      'locales' => array(),
    ),
    array(
      // New default drupal selectable long format.
      'type' => 'long',
      'format' => 'l, j. F, Y H:i',
      'locales' => array(),
    ),
  );
}

/**
 * Implements hook_date_format_types().
 */
function ding_base_date_format_types() {
  return array(
    'ding_date_only' => t('Date only (mainly used in events)'),
    'ding_time_only' => t('Time only (mainly used in events)'),
    'ding_long_date_only' => t('Long date only (mainly used in news)'),
    'ding_material_lists_date' => t('Ding marterial lists date'),
    'ding_event_lists_date' => t('Ding event lists date'),
  );
}

/**
 * Implements hook_element_info().
 */
function ding_base_element_info() {
  $types = array();

  $types['tableselect_form'] = array(
    '#input' => TRUE,
    '#js_select' => TRUE,
    '#multiple' => TRUE,
    '#process' => array('ding_base_element_process_tableselect_form'),
    '#options' => array(),
    '#empty' => '',
    '#theme' => 'tableselect_form',
  );

  $types['material_item'] = array(
    '#input' => TRUE,
    '#process' => array('ding_base_element_process_material_item'),
    '#theme' => 'material_item',
  );

  return $types;
}

/**
 * Process function for our element.
 */
function ding_base_element_process_tableselect_form($element) {
  if ($element['#multiple']) {
    $value = is_array($element['#value']) ? $element['#value'] : array();
  }
  else {
    // Advanced selection behaviour make no sense for radios.
    $element['#js_select'] = FALSE;
  }

  $element['#tree'] = TRUE;

  if (count($element['#options']) > 0) {
    if (!isset($element['#default_value']) || $element['#default_value'] === 0) {
      $element['#default_value'] = array();
    }

    // Create a checkbox or radio for each item in #options in such a way that
    // the value of the tableselect element behaves as if it had been of type
    // checkboxes or radios.
    foreach ($element['#options'] as $key => $choice) {
      // Do not overwrite manually created children.
      if (!isset($element[$key])) {
        if ($element['#multiple']) {
          $title = '';
          if (!empty($element['#options'][$key]['title']['data']['#title'])) {
            $title = t('Update @title', array(
              '@title' => $element['#options'][$key]['title']['data']['#title'],
            ));
          }
          $element[$key] = array(
            '#type' => 'checkbox',
            '#title' => $title,
            '#title_display' => 'invisible',
            '#return_value' => $key,
            '#default_value' => isset($value[$key]) ? $key : NULL,
            '#attributes' => $element['#attributes'],
          );
        }
        else {
          // Generate the parents as the autogenerator does, so we will have a
          // unique id for each radio button.
          $parents_for_id = array_merge($element['#parents'], array($key));
          $element[$key] = array(
            '#type' => 'radio',
            '#title' => '',
            '#return_value' => $key,
            '#default_value' => ($element['#default_value'] == $key) ? $key : NULL,
            '#attributes' => $element['#attributes'],
            '#parents' => $element['#parents'],
            '#id' => drupal_html_id('edit-' . implode('-', $parents_for_id)),
            '#ajax' => isset($element['#ajax']) ? $element['#ajax'] : NULL,
          );
        }
        if (isset($element['#options'][$key]['#weight'])) {
          $element[$key]['#weight'] = $element['#options'][$key]['#weight'];
        }

        // Add a reference to cell content in a hidden child of this
        // element. This means that form API will see them, and do the
        // appropriate processing.
        foreach ($element['#header'] as $fieldname => $title) {
          if (isset($element['#options'][$key][$fieldname]['data']) && is_array($element['#options'][$key][$fieldname]['data'])) {
            $element['_form_options'][$key][$fieldname] =& $element['#options'][$key][$fieldname]['data'];
          }
          elseif (!isset($element['#options'][$key][$fieldname]['data']) && is_array($element['#options'][$key][$fieldname])) {
            $element['_form_options'][$key][$fieldname] =& $element['#options'][$key][$fieldname];
          }
        }
      }
    }
  }
  else {
    $element['#value'] = array();
  }
  return $element;
}

/**
 * Theme function for our custom element.
 */
function theme_tableselect_form($variables) {
  $element = $variables['element'];
  $rows = array();
  $header = array();
  if (!empty($element['#options'])) {
    // Generate a table row for each selectable item in #options.
    foreach (element_children($element) as $key) {
      if ($key == '_form_options') {
        // Skip our hidden render sub-array.
        continue;
      }
      $row = array();

      $row['data'] = array();
      if (isset($element['#options'][$key]['#attributes'])) {
        $row += $element['#options'][$key]['#attributes'];
      }
      // Render the checkbox / radio element.
      $row['data'][] = drupal_render($element[$key]);

      // As theme_table only maps header and row columns by order, create the
      // correct order by iterating over the header fields.
      foreach ($element['#header'] as $fieldname => $title) {
        $row['data'][] = $element['#options'][$key][$fieldname];

        // Add classes to table header columns.
        $translated_title = $element['#header'][$fieldname];
        $header[$fieldname] = array('data' => $translated_title, 'class' => $fieldname);
      }
      $rows[] = $row;
    }
    // Add an empty header or a "Select all" checkbox to provide room for the
    // checkboxes/radios in the first table column.
    if ($element['#js_select']) {
      // Add a "Select all" checkbox.
      drupal_add_js('misc/tableselect.js');
      array_unshift($header, array('class' => array('select-all')));
    }
    else {
      // Add an empty header when radio buttons are displayed or a "Select all"
      // checkbox is not desired.
      array_unshift($header, '');
    }
  }

  return theme('table', array(
    'header' => $header,
    'rows' => $rows,
    'empty' => $element['#empty'],
    'attributes' => $element['#attributes'],
  ));
}

/**
 * Default implementation of the process function for the material item.
 *
 * Adds a checkbox to with a cover, title and extra information supplied in the
 * render array.
 */
function ding_base_element_process_material_item($element) {
  // Add the checkbox to the element.
  $element[$element['#id']] = array(
    '#type' => 'checkbox',
    '#return_value' => $element['#id'],
    '#attributes' => isset($element['#attributes']) ? $element['#attributes'] : array(),
    '#disabled' => isset($element['#disabled']) ? $element['#disabled'] : FALSE,
  );

  return $element;
}

/**
 * Default preprocess function for material_item theme function.
 */
function ding_base_preprocess_material_item(&$variables) {
  $element = $variables['element'];

  // Render the checkbox.
  $variables['checkbox'] = drupal_render($element[$element['#id']]);

  // Get the creator, materialtype, title and cover.
  if (isset($element['#creators'])) {
    // Concat creator(s) if needed.
    $creators = $element['#creators'];
    if (!is_array($creators)) {
      $creators = array($creators);
    }
    $variables['creators'] = implode(', ', $creators);
  }
  if (isset($element['#material_type'])) {
    $variables['material_type'] = $element['#material_type'];
  }
  $variables['title'] = $element['#title'];
  $variables['cover'] = drupal_render($element['#cover']);

  // Sort the information elements based on weight.
  uasort($element['#information'], 'element_sort');
  $variables['information'] = $element['#information'];

  // Check if material message have been set.
  if (isset($element['#material_message'])) {
    $variables['material_message'] = $element['#material_message'];
  }

  // Check if availability_id have been set.
  $variables['availability_id'] = NULL;
  if (isset($element['#availability_id'])) {
    $variables['availability_id'] = $element['#availability_id'];
  }
}

/**
 * Implements hook_pathauto_alias_alter().
 *
 * Try to force all content to language neutral to fix issues with content not
 * being display for all users.
 */
function ding_base_pathauto_alias_alter(&$alias, array &$context) {
  // Force all aliases to be saved as language neutral.
  $context['language'] = LANGUAGE_NONE;
}

/**
 * When using clean urls and OG this function helps create alias for taxonomy.
 *
 * Mainly used by ding_groups.
 *
 * @param stdClass $node
 *   Node entity object for the OG group that should have alias updated.
 * @param string $base
 *   Base path for the group (e.g. library or temaer).
 * @param array $terms
 *   The taxonomy terms objects to generate paths for.
 * @param array $slugs
 *   The sulg to use in the path (e.g. nyheder or arragementer).
 *
 * @todo: used it in ding_libraries to remove the "slug" field.
 */
function ding_base_updated_taxonomy_aliases(stdClass $node, $base, array $terms, array $slugs) {
  $group_alias = 'node/' . $node->nid;

  // Find node pattern from path auto.
  module_load_include('inc', 'pathauto');
  $pattern = pathauto_pattern_load_by_entity('node', $node->type);
  if ($pattern) {
    // Create node alias using token replace.
    $group_alias = token_replace($pattern, array('node' => $node), array(
      'sanitize' => FALSE,
      'clear' => TRUE,
      'callback' => 'pathauto_clean_token_values',
      'language' => (object) array('language' => LANGUAGE_NONE),
      'pathauto' => TRUE,
    ));
  }

  foreach ($slugs as $slug) {
    foreach ($terms as $term) {
      $source = $base . '/' . $node->nid . '/' . $slug . '/' . $term->tid;
      $existing_alias = _pathauto_existing_alias_data($source, LANGUAGE_NONE);
      $alias = $group_alias . '/' . $slug . '/' . $term->name;
      $alias = pathauto_cleanstring($alias);
      $alias = pathauto_clean_alias($alias);
      pathauto_alias_uniquify($alias, $source, LANGUAGE_NONE);

      if ($alias != $existing_alias['alias']) {
        $path = array(
          'source' => $source,
          'alias' => $alias,
          'language' => LANGUAGE_NONE,
        );

        // Set the alias or update it.
        _pathauto_set_alias($path, $existing_alias);
      }
    }
  }
}

/**
 * Get the list of css files to process by the color module.
 *
 * @param string $theme
 *   Theme name.
 *
 * @return array
 *   Files list.
 */
function ding_base_color_css_files($theme) {
  $files = array();

  $theme_path = drupal_realpath(drupal_get_path('theme', $theme)) . '/';
  foreach (file_scan_directory($theme_path . '/sass_css', '/\.css$/') as $file) {
    $files[] = str_replace($theme_path, '', drupal_realpath($file->uri));
  }

  return $files;
}

/**
 * Rewrite the color generated stylesheet.
 *
 * This function is used by "drush cgen" to regenerate the color modules css
 * file when the theme have changed it's css. We have tried to trigger the color
 * module to do this, but without any luck. So this basically do the same as
 * going into the theme settings page changing the color scheme and change it
 * back and press save.
 *
 * This manual step would create a large overhead in the automatically
 * deployment and in the development of the theme, so hence this function.
 */
function ding_base_rewrite_color_stylesheet() {
  $themes = list_themes();
  $theme = 'ddbasic';
  foreach ($themes as $name => $data) {
    if ($data->status) {
      $theme = $name;
      break;
    }
  }

  $info = color_get_info($theme);
  $palette = color_get_palette($theme);

  $info['css'] = ding_base_color_css_files($theme);

  // Prepare target locations for generated files.
  $id = $theme . '-' . substr(hash('sha256', serialize($palette) . microtime()), 0, 8);
  $paths['color'] = 'public://color';
  $paths['target'] = $paths['color'] . '/' . $id;
  foreach ($paths as $path) {
    file_prepare_directory($path, FILE_CREATE_DIRECTORY);
  }
  $paths['target'] = $paths['target'] . '/';
  $paths['id'] = $id;
  $paths['source'] = drupal_get_path('theme', $theme) . '/';
  $paths['files'] = $paths['map'] = array();

  // Rewrite theme stylesheets.
  $css = array();
  foreach ($info['css'] as $stylesheet) {
    // Build a temporary array with LTR and RTL files.
    $files = array();
    if (file_exists($paths['source'] . $stylesheet)) {
      $files[] = $stylesheet;

      $rtl_file = str_replace('.css', '-rtl.css', $stylesheet);
      if (file_exists($paths['source'] . $rtl_file)) {
        $files[] = $rtl_file;
      }
    }

    foreach ($files as $file) {
      // Aggregate @imports recursively for each configured top level CSS file
      // without optimization. Aggregation and optimization will be
      // handled by drupal_build_css_cache() only.
      $style = drupal_load_stylesheet($paths['source'] . $file, FALSE);

      // Return the path to where this CSS file originated from, stripping
      // off the name of the file at the end of the path.
      $base = base_path() . dirname($paths['source'] . $file) . '/';
      _drupal_build_css_path(NULL, $base);

      // Prefix all paths within this CSS file, ignoring absolute paths.
      $style = preg_replace_callback('/url\([\'"]?(?![a-z]+:|\/+)([^\'")]+)[\'"]?\)/i', '_drupal_build_css_path', $style);

      // Rewrite stylesheet with new colors.
      $style = _color_rewrite_stylesheet($theme, $info, $paths, $palette, $style);
      $base_file = drupal_basename($file);
      $css[] = $paths['target'] . $base_file;
      _color_save_stylesheet($paths['target'] . $base_file, $style, $paths);
    }
  }

  // Maintain list of files.
  variable_set('color_' . $theme . '_stylesheets', $css);
  variable_set('color_' . $theme . '_files', $paths['files']);
}

/**
 * Implements hook_field_widget_form_alter().
 */
function ding_base_field_widget_form_alter(&$elements, &$form_state, $context) {
  // Add help text describing resizing/cropping to image fields.
  $description = NULL;

  // First extract all indexes of image fields.
  $image_indexes = array_filter(element_children($elements),
    function ($i) use ($elements) {
      return isset($elements[$i]['#type']) && $elements[$i]['#type'] == 'media';
    }
  );

  foreach ($elements as $i => &$element) {
    // Skip non-image elements.
    if (!in_array($i, $image_indexes)) {
      continue;
    }

    $display = NULL;
    $displays = $context['instance']['display'];
    // By default we trying to get default display.
    if (isset($displays['default']) && $displays['default']['type'] != 'hidden') {
      $display = $displays['default'];
    }
    // Otherwise, we will get first display which has some styles.
    else {
      $displays = array_filter($context['instance']['display'], function ($i) {
        return isset($i['settings']['styles']) && !empty($i['settings']['styles']);
      });
      $display = !empty($displays) ? reset($displays) : NULL;
    }

    if (!empty($display)) {
      // We will use functionality of image module.
      $style = image_style_load($display['settings']['styles']['max_style']);
      // Let's use sample file from image module, for applying all effects.
      $original_path = variable_get('image_style_preview_image', drupal_get_path('module', 'image') . '/sample.png');
      $original_sample = image_get_info($original_path);

      // Apply style to sample image.
      $preview_file = image_style_path($style['name'], $original_path);
      if (!file_exists($preview_file)) {
        image_style_create_derivative($style, $original_path, $preview_file);
      }

      $preview_image = image_get_info($preview_file);
      $dimensions = array(
        'width' => $preview_image['width'],
        'height' => $preview_image['height'],
      );

      // If after apllying effects dimensions wasn't changed, when we can't
      // recommend.
      if ($dimensions['height'] != $original_sample['height'] && $dimensions['width'] != $original_sample['width']) {
        array_walk($dimensions, function (&$i, $k) {
          $i = "{$i}px {$k}";
        });

        $description = t("The image will automatically be resized. The maximum dimensions are %dimensions (Original: {$original_sample['width']}x{$original_sample['height']}).", array(
          '%dimensions' => implode(' and ', $dimensions),
        ));
      }
    }
  }

  if (!empty($description)) {
    $elements['#suffix'] = $description;
  }

}

/**
 * Get the first value of a field item.
 *
 * This is a simple wrapper for the field_get_items() function.
 */
function ding_base_get_value($entity_type, $entity, $field_name, $field_value = 'value', $default = FALSE) {
  $items = field_get_items($entity_type, $entity, $field_name);
  if ($items !== FALSE) {
    if (isset($items[0][$field_value])) {
      return $items[0][$field_value];
    }
  }

  return $default;
}

/**
 * Get the fields, like field_get_items. But always return an array.
 *
 * This way you don't have to check for FALSE in your own code, but can move
 * straight into a foreach loop.
 */
function ding_base_get_items($entity_type, $entity, $field_name) {
  $items = field_get_items($entity_type, $entity, $field_name);
  if ($items === FALSE) {
    return array();
  }
  return $items;
}

/**
 * Implements hook_js_alter().
 */
function ding_base_js_alter(&$javascript) {
  if (isset($javascript['profiles/ding2/modules/contrib/lazy_pane/js/lazy-pane.js'])) {
    drupal_add_js(drupal_get_path('module', 'ding_base') . '/js/lazy-pane-fix.js');
  }
}

/**
 * Implements hook_page_delivery_callback_alter()
 *
 * Override the default ajax_deliver callback on lazy_pane requests, so we can
 * handle empty panes.
 */
function ding_base_page_delivery_callback_alter(&$callback) {
  if (lazy_pane_is_lazy_request()) {
    $callback = 'ding_base_lazy_pane_ajax_deliver';
  }
}

/**
 * This callback is used on lazy_pane requests.
 *
 * It will look for empty inserts, and change the command to use the
 * ding_base_lazy_pan_remove_pane (see js/lazy-pane-fix.js) instead.
 */
function ding_base_lazy_pane_ajax_deliver($page_callback_result) {
  foreach ($page_callback_result['#commands'] as &$command) {
    if ($command['command'] === 'insert' && $command['data'] === NULL) {
      $command['command'] = 'ding_base_lazy_pane_remove_pane';
    }
  }

  return ajax_deliver($page_callback_result);
}

/**
 * Validate an email.
 *
 * This check uses Drupals valid_email_addess(), and makes sure the domain used
 * is a valid top level domain.
 *
 * @param string $email
 *   The email to validate.
 *
 * @return bool
 *   TRUE if the address is in a valid format.
 */
function ding_base_validate_email($email) {
  // If < and > are used, set the email to the data encapsulated by these
  // characters.
  if (preg_match('/<([^>]*)>/', $email, $matches)) {
    $email = $matches[1];
  }

  if (!valid_email_address($email)) {
    return FALSE;
  }

  $tld_list = array();
  if ($cache = cache_get('ding_base:tld_list')) {
    $tld_list = $cache->data;
  }
  else {
    // We assume iana will keep the list of tlds in the same format and on the
    // same URL. It's been the same URL and format since 2004.
    // If the response fails the $tld_list will be empty and we'll simply skip
    // the domain check.
    $response = drupal_http_request('http://data.iana.org/TLD/tlds-alpha-by-domain.txt');
    if ($response->code == 200) {
      $tld_list = explode("\n", $response->data);
      cache_set('ding_base:tld_list', $tld_list);
    }
  }

  $domain = strtoupper(substr($email, strrpos($email, '.') + 1));
  return empty($tld_list) || in_array($domain, $tld_list);
}

/**
 * Implements hook_views_default_views_alter().
 *
 * Adding custom Taxonomy Terms filter to admin_views_node view.
 */
function ding_base_views_default_views_alter(&$views) {
  if (isset($views['admin_views_node'])) {
    $view = &$views['admin_views_node'];
    $filter_options = [
      'id' => 'ding_base_term_name',
      'table' => 'taxonomy_term_data',
      'field' => 'name',
      'relationship' => 'term_node_tid',
      'group_type' => 'group',
      'operator' => "contains",
      'value' => '',
      'group' => 1,
      'exposed' => TRUE,
      'required' => FALSE,
      'type' => 'text',
      'expose' => [
        'operator_id' => 'name_op',
        'label' => t('Terms'),
        'operator' => 'name_op',
        'identifier' => 'ding_base_term_name',
      ],
    ];

    $filters = $view->display['default']->display_options['filters'];

    if (empty($filters['name'])) {
      // There is no such filter so we have to add it.
      $views['admin_views_node']->display['default']->display_options['filters']['name'] = $filter_options;
    }
  }
}

/**
 * Implements hook_form_alter().
 */
function ding_base_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'views_exposed_form' && $form_state['view']->name == 'admin_views_node') {
    $form['ding_base_term_name']['#type'] = 'textfield';
    $form['ding_base_term_name']['#id'] = 'edit-ding-base-term-name';
    $form['ding_base_term_name']['#attached']['js'][] = [
      'data' => drupal_get_path('module', 'ding_base') . '/js/ding_base.prevent_auto_submit.js',
      'type' => 'file',
    ];

    // If no vocabulary selected, disable "Terms" filter.
    if ($form_state['input']['vid'] == 'All') {
      $form['ding_base_term_name']['#attributes'] = [
        'disabled' => TRUE,
      ];
    }
    else {
      $vid = $form_state['input']['vid'];
      $form['ding_base_term_name']['#autocomplete_path'] = 'ding_base/taxonomy/autocomplete/' . $vid;
      $form['ding_base_term_name']['#description'] = t('Autocomplete with terms of selected vocabulary');
      $form['ding_base_term_name']['#attributes'] = [
        'class' => [
          'ctools-auto-submit-exclude',
        ],
      ];
    }
  }
  elseif (strpos($form_id, 'webform_client_form') === 0) {
    // Add a notice about not inserting personal on every webform. The link is
    // hardcoded since we currently don't have any central place for setting
    // up a privacy poplicy page, and we use translation here primarly for
    // administrators to be able to change the link.
    $privacy_notice = t('Please do not enter your civil registration number (CPR) or sensitive information of any kind in the form. Read more in our <a href="/persondata">privacy policy</a>');
    $form['submitted']['privacy_notice'] = [
      '#type' => 'item',
      '#markup' => '<p>' . $privacy_notice . '</p>',
      // Ensure notice is placed at the bottom just above submit button.
      '#weight' => 50,
    ];
  }
  // Action forms got a weird naming scheme, so match a prefix and check if
  // the 'add_roles' and 'remove_roles' form elements is present.
  elseif (strpos($form_id, 'views_form_admin_views_user') === 0 &&
          isset($form['add_roles']) && isset($form['remove_roles'])) {
    // Limit options to roles the user has been delegated using the
    // role_delegation module.
    foreach (['add_roles', 'remove_roles'] as $element) {
      foreach ($form[$element]['#options'] as $rid => $role) {
        if (!user_access('assign all roles') && !user_access("assign $role role")) {
          unset($form[$element]['#options'][$rid]);
        }
      }
    }
  }
}

/**
 * Implements hook_preprocess_HOOK().
 *
 * Used for changing order of filter fields, so the "Terms" filter is positioned
 * right after "Vocabulary" filter.
 */
function ding_base_preprocess_views_exposed_form(&$variables) {
  if (isset($variables['form']) && $variables['form']['#id'] == 'views-exposed-form-admin-views-node-system-1') {
    $widgets = $variables['widgets'];

    // Get widgets keys for further processing.
    $widgets_keys = array_keys($widgets);

    // Switch key with value, to have an numeric value.
    $widgets_keys = array_flip($widgets_keys);

    // Getting Vocabulary filter position.
    $vid_position = $widgets_keys['filter-vid'];
    // Set needed position to Taxonomy terms filter field.
    $widgets_keys['filter-name'] = $vid_position + 1;

    // Modifying positions.
    foreach ($widgets_keys as $key => $pos) {
      if ($pos >= $widgets_keys['filter-name'] && $key != 'filter-name') {
        $widgets_keys[$key] = $pos + 1;
      }
    }

    // Flip array to get numeric values as keys.
    $normalize = array_flip($widgets_keys);

    // Sort array by numeric keys.
    ksort($normalize, SORT_ASC);

    // Prepare ordered array.
    $normalized = array_flip($normalize);

    // Order widgets objects by correctly positioned structure.
    $widgets = array_merge($normalized, $widgets);

    // Return widgets back in variables.
    $variables['widgets'] = $widgets;
  }
}

/**
 * Admin content "Terms" filter autocomplete callback.
 */
function ding_base_taxonomy_autocomplete($vid, $tag) {
  if (!empty($vid)) {
    $tags = db_select('taxonomy_term_data', 't')
      ->fields('t', ['tid', 'name'])
      ->condition('vid', $vid)
      ->condition('t.name', '%' . db_like($tag) . '%', 'LIKE')
      ->execute()
      ->fetchAll();

    $items = [];
    foreach ($tags as $item) {
      $items[$item->name] = $item->name;
    }

    drupal_json_output($items);
  }
}
