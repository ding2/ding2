<?php

/**
 * @file
 * Code for the Ding App Content RSS feature.
 */

include_once 'ding_app_content_rss.features.inc';

/**
 * Implements hook_views_pre_render().
 *
 * Search and replace internal ting object links to bappsp links.
 */
function ding_app_content_rss_views_pre_render(&$view) {
  if ($view->name == 'ding_app_content_event_rss' || $view->name == 'ding_app_content_news_rss') {
    foreach ($view->result as $key => $result) {
      if ($view->name == 'ding_app_content_event_rss') {
        $view->result[$key]->field_field_ding_event_body[0]['rendered'] = ding_app_content_rss_ting_links_convert($result->field_field_ding_event_body[0]['rendered']);
      }
    }
  }
}

/**
 * Implements hook_field_formatter_info().
 */
function ding_app_content_rss_field_formatter_info() {
  return [
    'ding_app_content_rss_location' => [
      'label' => t('RSS friendly location'),
      'field types' => ['addressfield'],
      'description' => t('Output address information on a single HTML stripped line.'),
    ],
    'ding_app_content_rss_date_time' => [
      'label' => t('RFC-2822 formatted date'),
      'field types' => ['datetime'],
      'description' => t('Format date and time as RFC-2822 date/time string.'),
    ],
  ];
}

/**
 * Implements hook_field_formatter_view().
 */
function ding_app_content_rss_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = [];
  switch ($display['type']) {
    case 'ding_app_content_rss_date_time':
      foreach ($items as $delta => $item) {
        $element[$delta] = [
          '#markup' => strtotime($item[$display['settings']['fromto']] . ' ' . $item['timezone_db']),
        ];
      }
      break;

    case 'ding_app_content_rss_location':
      foreach ($items as $delta => $item) {
        $location = [];

        $accepted_fields = [
          'name_line',
          'thoroughfare',
          'postal_code',
          'locality',
          'country',
        ];
        if (!empty($item['name_line'])) {
          foreach ($item as $key => $part) {
            if (!empty($part) && in_array($key, $accepted_fields)) {
              $location[] = $part;
            }
          }
        }
        else {
          // Try to get library title as location.
          $wrapper = entity_metadata_wrapper('node', $entity);
          $libraries = $wrapper->og_group_ref->value();
          foreach ($libraries as $library) {
            $location[] = $library->title;
          }
        }

        // Fallback to groups title for location.
        if (count($location) == 0) {
          $wrapper = entity_metadata_wrapper('node', $entity);
          $groups = $wrapper->ding_event_groups_ref->value();
          foreach ($groups as $group) {
            $location[] = $group->title;
          }
        }

        $element[$delta] = [
          '#markup' => implode(', ', array_reverse($location)),
        ];
      }
      break;
  }
  return $element;
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function ding_app_content_rss_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];
  $form = [];
  $form['fromto'] = [
    '#title' => t('Display:'),
    '#type' => 'select',
    '#options' => [
      'value' => t('Start date only'),
      'value2' => t('End date only'),
    ],
    '#access' => $field['settings']['todate'],
    '#default_value' => $settings['fromto'],
    '#weight' => 1,
  ];

  return $form;
}

/**
 * Implements hook_views_rss_namespaces().
 */
function ding_app_content_rss_views_rss_namespaces() {
  $namespaces['content-rss'] = [
    'prefix' => 'xmlns',
    'uri' => 'http://xml.redia.dk/rss',
  ];
  return $namespaces;
}

/**
 * Implements hook_views_rss_item_elements().
 */
function ding_app_content_rss_views_rss_item_elements() {
  return [
    'content-rss:subheadline' => [
      'title' => t('Subheadline'),
      'description' => t('The subheadline'),
    ],
    'content-rss:arrangement-starttime' => [
      'title' => t('Event starttime'),
      'description' => t('When does the event start (UTC Timestamp)'),
    ],
    'content-rss:arrangement-endtime' => [
      'title' => t('Event endtime'),
      'description' => t('When does the event end (UTC Timestamp)'),
    ],
    'content-rss:display-starttime' => [
      'title' => t('Display starttime'),
      'description' => t('Start displaying the event at (UTC Timestamp)'),
    ],
    'content-rss:display-endtime' => [
      'title' => t('Display endtime'),
      'description' => t('End displaying the event at (UTC Timestamp)'),
    ],
    'content-rss:arrangement-location' => [
      'title' => t('Event location'),
      'description' => t('The location of the event'),
    ],
    'content-rss:arrangement-price' => [
      'title' => t('Event price'),
      'description' => t('The price of the event.'),
    ],
    'content-rss:arrangement-sales-status' => [
      'title' => t('Event tickets sales status'),
      'description' => t('The status of event tickets sales.'),
    ],
    'content-rss:resources' => [
      'title' => t('Redia resources'),
      'description' => t('The node id of a type which has a relation to ting objects.'),
      'preprocess functions' => ['ding_app_content_rss_preprocess_item_resources'],
    ],
    'content-rss:library-id' => [
      'title' => t('Library ID'),
      'description' => t('Identificator of library to which this node is assigned.'),
    ],
    'content-rss:booking-url' => [
      'title' => t('Booking URL'),
      'description' => t('Link to tickets.'),
    ],
    'content-rss:promoted' => [
      'title' => t('Promoted to front page'),
      'description' => t('Boolean value for promoted to front page.'),
    ],
    'content-rss:sticky' => [
      'title' => t('Sticky'),
      'description' => t('Boolean value for sticky.'),
    ],
    'content-rss:place_room' => [
      'title' => t('Place/Room'),
      'description' => t('Use this to direct your guests to the correct place'),
    ],
    'content-rss:organizers' => [
      'title' => t('Organizers'),
      'description' => t('One or more organizers of the event.'),
    ],
  ];
}

/**
 * Converting links to ting materials into bappsp links.
 *
 * @param string $value
 *   The text to be processed.
 *
 * @return string|string[]|null
 */
function ding_app_content_rss_ting_links_convert($value) {
  return preg_replace('#http://([\w\.])+(/ting)/(.+)#Ui', 'bappsp://$3', $value);
}

/**
 * Preprocess <description> property.
 */
function ding_app_content_rss_preprocess_description(&$variables) {
  if (isset($variables['view']) && $variables['view']->name == 'ding_app_content_news_rss') {
    $result = [];

    foreach ($variables['raw'] as $key => $paragraph) {
      /** @var \ParagraphsItemEntity $paragraph_entity */
      $paragraph_entity = paragraphs_item_load($paragraph['raw']['value']);

      switch ($paragraph_entity->bundle) {
        case 'ding_paragraphs_text':
          $build = [];
          $markup = $paragraph_entity->field_ding_paragraphs_text[LANGUAGE_NONE][0]['safe_value'];
          $build['paragraph-markup'] = ding_app_content_rss_ting_links_convert($markup);
          break;

        case 'ding_paragraphs_image_and_text':
          $build = [];
          $images = [];
          $images_content = $paragraph_entity->field_ding_paragraphs_image[LANGUAGE_NONE];
          foreach ($images_content as $item) {
            $images[] = [
              'key' => 'paragraph-image',
              'value' => file_create_url($item['uri']),
            ];
          }

          $build['paragraph-images'] = $images;
          $build['paragraph-image-position'] = $paragraph_entity->field_ding_paragraphs_position[LANGUAGE_NONE][0]['value'];
          $build['paragraph-display'] = $paragraph_entity->field_ding_paragraphs_display[LANGUAGE_NONE][0]['value'];
          $markup = $paragraph_entity->field_ding_paragraphs_text[LANGUAGE_NONE][0]['safe_value'];
          $build['paragraph-markup'] = ding_app_content_rss_ting_links_convert($markup);
          break;

        case 'ding_paragraphs_text_box':
          $build = [];
          $build['paragraph-display'] = $paragraph_entity->field_ding_paragraphs_display[LANGUAGE_NONE][0]['value'];
          $markup = $paragraph_entity->field_ding_paragraphs_box_text[LANGUAGE_NONE][0]['safe_value'];
          $build['paragraph-markup'] = ding_app_content_rss_ting_links_convert($markup);
          break;

        case 'ding_paragraphs_material_list':
        case 'ding_paragraphs_carousel':
          $build = [];
          $resources = [];
          $materials = $paragraph_entity->field_ding_paragraphs_material[LANGUAGE_NONE];
          foreach ($materials as $material) {
            $relation = relation_load($material['value']->rid);
            $endpoints = relation_get_endpoints($relation);
            $ting_object = reset($endpoints['ting_object']);
            if (!$ting_object) {
              continue;
            }
            $resources[] = [
              'key' => 'paragraph-resource',
              'value' => explode(':', $ting_object->ding_entity_id)[1],
            ];
          }
          $build['paragraph-resources'] = $resources;
          break;

        case 'ding_paragraphs_image':
          $build = [];
          $images = [];
          $images_content = $paragraph_entity->field_ding_paragraphs_image[LANGUAGE_NONE];
          foreach ($images_content as $item) {
            $images[] = [
              'key' => 'paragraph-image',
              'value' => file_create_url($item['uri']),
            ];
          }
          $build['paragraph-images'] = $images;
          $build['paragraph-display'] = $paragraph_entity->field_ding_paragraphs_display[LANGUAGE_NONE][0]['value'];
          break;

        case 'ding_paragraphs_single_material':
          $build = [];
          $build['paragraph-display'] = $paragraph_entity->field_ding_paragraphs_display[LANGUAGE_NONE][0]['value'];
          if (!empty($paragraph_entity->field_ding_paragraphs_single_mat)) {
            $relation = relation_load($paragraph_entity->field_ding_paragraphs_single_mat[LANGUAGE_NONE][0]['value']->rid);
            $endpoints = relation_get_endpoints($relation);
            $ting_object = reset($endpoints['ting_object']);
            if ($ting_object) {
              $build['paragraph-resource'] = explode(':', $ting_object->ding_entity_id)[1];
            }
          }
          break;
      }

      $result['paragraphs'][] = [
        'key' => 'paragraph',
        'value' => $build,
        'attributes' => ['type' => $paragraph_entity->bundle],
      ];
    }

    $variables['elements'][0]['value'] = $result;
  }
}

/**
 * Preprocess function for item <resources> elements.
 */
function ding_app_content_rss_preprocess_item_resources(&$variables) {
  // Load the node via entity metadata wrapper.
  $node = entity_metadata_wrapper('node', node_load($variables['elements'][0]['value']));
  $value = [];

  // The relation name is the same even though field names differ between
  // content types.
  if ($node->relation_ting_reference_ting_object) {
    foreach ($node->relation_ting_reference_ting_object->value() as $ting_object) {
      // The id should be in the format 870970-basis:24945669 where the
      // last part constitutes the FAUST-number which is required by the
      // Redia format.
      $id_parts = explode(':', $ting_object->id);
      $faust_number = end($id_parts);

      $value[] = [
        // This must be the name of the tag wrapping each value.
        'key' => 'content-rss:resource',
        'value' => $faust_number,
      ];
    }
  }

  // Replace the existing values with the new array.
  $variables['elements']['0']['value'] = $value;
}

/**
 * Implements hook_views_rss_item_elements_alter().
 */
function ding_app_content_rss_views_rss_item_elements_alter(&$elements) {
  $elements['views_rss_core']['description']['preprocess functions'][] = 'ding_app_content_rss_preprocess_description';
}

/**
 * Implements hook_views_rss_feed_alter().
 */
function ding_app_content_rss_views_rss_feed_alter(&$rss_feed) {
  $channel = &$rss_feed['value'][0]['value'];
  foreach ($channel as $key => &$channel_item) {
    switch ($channel_item['key']) {
      case 'item':
        $item = &$channel_item['value'];
        foreach ($item as $i => &$element) {
          switch ($element['key']) {
            case 'description':
              $element['value'] = htmlspecialchars(format_xml_elements($element['value']));
              $element['encoded'] = TRUE;
              break;
          }
        }
        break;
    }
  }
}
